import{ERROR_THRESHOLD}from"./common.js";import EventType from"../events/EventType.js";import Tile from"../Tile.js";import TileState from"../TileState.js";import Triangulation from"./Triangulation.js";import{calculateSourceExtentResolution,canvasPool,render as renderReprojected}from"../reproj.js";import{clamp}from"../math.js";import{getArea,getIntersection}from"../extent.js";import{listen,unlistenByKey}from"../events.js";import{releaseCanvas}from"../dom.js";class ReprojTile extends Tile{constructor(t,i,e,s,r,o,a,l,n,h,c,u){super(r,TileState.IDLE,u),this.renderEdges_=void 0!==c&&c,this.pixelRatio_=a,this.gutter_=l,this.canvas_=null,this.sourceTileGrid_=i,this.targetTileGrid_=s,this.wrappedTileCoord_=o||r,this.sourceTiles_=[],this.sourcesListenerKeys_=null,this.sourceZ_=0;u=s.getTileCoordExtent(this.wrappedTileCoord_),c=this.targetTileGrid_.getExtent();let T=this.sourceTileGrid_.getExtent();l=c?getIntersection(u,c):u;if(0===getArea(l))this.state=TileState.EMPTY;else{o=t.getExtent(),r=(o&&(T=T?getIntersection(T,o):o),s.getResolution(this.wrappedTileCoord_[0])),c=calculateSourceExtentResolution(t,e,l,r);if(!isFinite(c)||c<=0)this.state=TileState.EMPTY;else if(this.triangulation_=new Triangulation(t,e,l,T,c*(void 0!==h?h:ERROR_THRESHOLD),r),0===this.triangulation_.getTriangles().length)this.state=TileState.EMPTY;else{this.sourceZ_=i.getZForResolution(c);let e=this.triangulation_.calculateSourceExtent();if(T&&(t.canWrapX()?(e[1]=clamp(e[1],T[1],T[3]),e[3]=clamp(e[3],T[1],T[3])):e=getIntersection(e,T)),getArea(e)){var _=i.getTileRangeForExtentAndZ(e,this.sourceZ_);for(let t=_.minX;t<=_.maxX;t++)for(let e=_.minY;e<=_.maxY;e++){var g=n(this.sourceZ_,t,e,a);g&&this.sourceTiles_.push(g)}0===this.sourceTiles_.length&&(this.state=TileState.EMPTY)}else this.state=TileState.EMPTY}}}getImage(){return this.canvas_}reproject_(){const t=[];var e,i,s,r,o;this.sourceTiles_.forEach(e=>{e&&e.getState()==TileState.LOADED&&t.push({extent:this.sourceTileGrid_.getTileCoordExtent(e.tileCoord),image:e.getImage()})}),(this.sourceTiles_.length=0)===t.length?this.state=TileState.ERROR:(s=this.wrappedTileCoord_[0],e="number"==typeof(i=this.targetTileGrid_.getTileSize(s))?i:i[0],i="number"==typeof i?i:i[1],s=this.targetTileGrid_.getResolution(s),r=this.sourceTileGrid_.getResolution(this.sourceZ_),o=this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_),this.canvas_=renderReprojected(e,i,this.pixelRatio_,r,this.sourceTileGrid_.getExtent(),s,o,this.triangulation_,t,this.gutter_,this.renderEdges_,this.interpolate),this.state=TileState.LOADED),this.changed()}load(){if(this.state==TileState.IDLE){this.state=TileState.LOADING,this.changed();let r=0;this.sourcesListenerKeys_=[],this.sourceTiles_.forEach(i=>{var e=i.getState();if(e==TileState.IDLE||e==TileState.LOADING){r++;const s=listen(i,EventType.CHANGE,function(e){var t=i.getState();t!=TileState.LOADED&&t!=TileState.ERROR&&t!=TileState.EMPTY||(unlistenByKey(s),0===--r&&(this.unlistenSources_(),this.reproject_()))},this);this.sourcesListenerKeys_.push(s)}}),0===r?setTimeout(this.reproject_.bind(this),0):this.sourceTiles_.forEach(function(e,t,i){e.getState()==TileState.IDLE&&e.load()})}}unlistenSources_(){this.sourcesListenerKeys_.forEach(unlistenByKey),this.sourcesListenerKeys_=null}release(){this.canvas_&&(releaseCanvas(this.canvas_.getContext("2d")),canvasPool.push(this.canvas_),this.canvas_=null),super.release()}}export default ReprojTile;