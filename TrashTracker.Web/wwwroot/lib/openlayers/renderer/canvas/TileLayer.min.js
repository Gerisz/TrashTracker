import CanvasLayerRenderer from"./Layer.js";import ImageTile from"../../ImageTile.js";import ReprojTile from"../../reproj/Tile.js";import TileRange from"../../TileRange.js";import TileState from"../../TileState.js";import{apply as applyTransform,compose as composeTransform,makeInverse,toString as toTransformString}from"../../transform.js";import{ascending}from"../../array.js";import{containsCoordinate,createEmpty,equals,getHeight,getIntersection,getRotatedViewport,getTopLeft,getWidth,intersects}from"../../extent.js";import{fromUserExtent}from"../../proj.js";import{getUid}from"../../util.js";import{toSize}from"../../size.js";class CanvasTileLayerRenderer extends CanvasLayerRenderer{constructor(e){super(e),this.extentChanged=!0,this.renderedExtent_=null,this.renderedPixelRatio,this.renderedProjection=null,this.renderedRevision,this.renderedTiles=[],this.newTiles_=!1,this.tmpExtent=createEmpty(),this.tmpTileRange_=new TileRange(0,0,0,0)}isDrawableTile(e){const t=this.getLayer();var e=e.getState(),i=t.getUseInterimTilesOnError();return e==TileState.LOADED||e==TileState.EMPTY||e==TileState.ERROR&&!i}getTile(e,t,i,r){var o=r.pixelRatio,r=r.viewState.projection;const n=this.getLayer(),a=n.getSource();let s=a.getTile(e,t,i,o,r);return s.getState()==TileState.ERROR&&n.getUseInterimTilesOnError()&&0<n.getPreload()&&(this.newTiles_=!0),s=this.isDrawableTile(s)?s:s.getInterimTile()}getData(e){var t=this.frameState;if(!t)return null;const i=this.getLayer();var r=applyTransform(t.pixelToCoordinateTransform,e.slice()),e=i.getExtent();if(e&&!containsCoordinate(e,r))return null;var o=t.pixelRatio,n=t.viewState.projection,a=t.viewState;const s=i.getRenderSource(),l=s.getTileGridForProjection(a.projection);var d=s.getTilePixelRatio(t.pixelRatio);for(let e=l.getZForResolution(a.resolution);e>=l.getMinZoom();--e){var g,h,T,m,c=l.getTileCoordForCoordAndZ(r,e);const p=s.getTile(e,c[1],c[2],o,n);if(!(p instanceof ImageTile||p instanceof ReprojTile)||p instanceof ReprojTile&&p.getState()===TileState.EMPTY)return null;if(p.getState()!==TileState.LOADED);else return T=l.getOrigin(e),g=toSize(l.getTileSize(e)),m=l.getResolution(e),h=Math.floor(d*((r[0]-T[0])/m-c[1]*g[0])),T=Math.floor(d*((T[1]-r[1])/m-c[2]*g[1])),m=Math.round(d*s.getGutterForProjection(a.projection)),this.getImageData(p.getImage(),h+m,T+m)}return null}loadedTileCallback(e,t,i){return!!this.isDrawableTile(i)&&super.loadedTileCallback(e,t,i)}prepareFrame(e){return!!this.getLayer().getSource()}renderFrame(r,z){var o=r.layerStatesArray[r.layerIndex],e=r.viewState,t=e.projection,_=e.resolution,i=e.center,n=e.rotation,a=r.pixelRatio;const O=this.getLayer(),s=O.getSource();var Z=s.getRevision();const l=s.getTileGridForProjection(t);var d=l.getZForResolution(_,s.zDirection),g=l.getResolution(d);let h=r.extent;var k=r.viewState.resolution,T=s.getTilePixelRatio(a),m=Math.round(getWidth(h)/k*a),c=Math.round(getHeight(h)/k*a),Y=o.extent&&fromUserExtent(o.extent,t);Y&&(h=getIntersection(h,fromUserExtent(o.extent,t)));const p=g*m/2/T,u=g*c/2/T;var f=[i[0]-p,i[1]-u,i[0]+p,i[1]+u],v=l.getTileRangeForExtentAndZ(h,d);const R={},V=(R[d]={},this.createLoadedTileFinder(s,t,R));var q=this.tmpExtent,G=this.tmpTileRange_,K=(this.newTiles_=!1,n?getRotatedViewport(e.center,k,n,r.size):void 0);for(let i=v.minX;i<=v.maxX;++i)for(let t=v.minY;t<=v.maxY;++t)if(!n||l.tileCoordIntersectsViewport([d,i,t],K)){const F=this.getTile(d,i,t,r);if(this.isDrawableTile(F)){var x=getUid(this);if(F.getState()==TileState.LOADED){let e=(R[d][F.tileCoord.toString()]=F).inTransition(x);e&&1!==o.opacity&&(F.endTransition(x),e=!1),this.newTiles_||!e&&this.renderedTiles.includes(F)||(this.newTiles_=!0)}if(1===F.getAlpha(x,r.time))continue}x=l.getTileCoordChildTileRange(F.tileCoord,G,q);let e=!1;(e=x?V(d+1,x):e)||l.forEachTileCoordParentTileRange(F.tileCoord,V,G,q)}var S=g/_*a/T,i=(composeTransform(this.pixelTransform,r.size[0]/2,r.size[1]/2,1/a,1/a,n,-m/2,-c/2),toTransformString(this.pixelTransform));this.useContainer(z,i,this.getBackground(r));const y=this.getRenderContext(r),C=this.context.canvas;makeInverse(this.inversePixelTransform,this.pixelTransform),composeTransform(this.tempTransform,m/2,c/2,S,S,0,-m/2,-c/2),C.width!=m||C.height!=c?(C.width=m,C.height=c):this.containerReused||y.clearRect(0,0,m,c),Y&&this.clipUnrotated(y,r,Y),s.getInterpolate()||(y.imageSmoothingEnabled=!1),this.preRender(y,r),this.renderedTiles.length=0;let w=Object.keys(R).map(Number);w.sort(ascending);let E,X,j;1!==o.opacity||this.containerReused&&!s.getOpaque(r.viewState.projection)?(E=[],X=[]):w=w.reverse();for(let e=w.length-1;0<=e;--e){var I=w[e],H=s.getTilePixelSize(I,a,t),Q=l.getResolution(I)/g;const p=H[0]*Q*S,u=H[1]*Q*S;var W=l.getTileCoordForCoordAndZ(getTopLeft(f),I),H=l.getTileCoordExtent(W),B=applyTransform(this.tempTransform,[T*(H[0]-f[0])/g,T*(f[3]-H[3])/g]),N=T*s.getGutterForProjection(t),J=R[I];for(const ie in J){const M=J[ie];var P,L=M.tileCoord,$=W[1]-L[1],ee=Math.round(B[0]-($-1)*p),L=W[2]-L[2],te=Math.round(B[1]-(L-1)*u),U=Math.round(B[0]-$*p),b=Math.round(B[1]-L*u),A=ee-U,D=te-b,$=d===I,L=$&&1!==M.getAlpha(getUid(this),r.time);let i=!1;if(!L)if(E){j=[U,b,U+A,b,U+A,b+D,U,b+D];for(let e=0,t=E.length;e<t;++e)d!==I&&I<X[e]&&(P=E[e],intersects([U,b,U+A,b+D],[P[0],P[3],P[4],P[7]])&&(i||(y.save(),i=!0),y.beginPath(),y.moveTo(j[0],j[1]),y.lineTo(j[2],j[3]),y.lineTo(j[4],j[5]),y.lineTo(j[6],j[7]),y.moveTo(P[6],P[7]),y.lineTo(P[4],P[5]),y.lineTo(P[2],P[3]),y.lineTo(P[0],P[1]),y.clip()));E.push(j),X.push(I)}else y.clearRect(U,b,A,D);this.drawTileImage(M,r,U,b,A,D,N,$),E&&!L?(i&&y.restore(),this.renderedTiles.unshift(M)):this.renderedTiles.push(M),this.updateUsedTiles(r.usedTiles,s,M)}}return this.renderedRevision=Z,this.renderedResolution=g,this.extentChanged=!this.renderedExtent_||!equals(this.renderedExtent_,f),this.renderedExtent_=f,this.renderedPixelRatio=a,this.renderedProjection=t,this.manageTilePyramid(r,s,l,a,t,h,d,O.getPreload()),this.scheduleExpireCache(r,s),this.postRender(this.context,r),o.extent&&y.restore(),y.imageSmoothingEnabled=!0,i!==C.style.transform&&(C.style.transform=i),this.container}drawTileImage(e,t,i,r,o,n,a,s){var l=this.getTileImage(e);if(l){const m=this.getRenderContext(t);var d=getUid(this),g=t.layerStatesArray[t.layerIndex],h=g.opacity*(s?e.getAlpha(d,t.time):1),T=h!==m.globalAlpha;T&&(m.save(),m.globalAlpha=h),m.drawImage(l,a,a,l.width-2*a,l.height-2*a,i,r,o,n),T&&m.restore(),h!==g.opacity?t.animate=!0:s&&e.endTransition(d)}}getImage(){var e=this.context;return e?e.canvas:null}getTileImage(e){return e.getImage()}scheduleExpireCache(e,t){t.canExpireCache()&&(t=function(e,t,i){var r=getUid(e);r in i.usedTiles&&e.expireCache(i.viewState.projection,i.usedTiles[r])}.bind(null,t),e.postRenderFunctions.push(t))}updateUsedTiles(e,t,i){t=getUid(t);t in e||(e[t]={}),e[t][i.getKey()]=!0}manageTilePyramid(e,t,i,r,o,n,a,s,l){var d=getUid(t);d in e.wantedTiles||(e.wantedTiles[d]={});const g=e.wantedTiles[d],h=e.tileQueue;var T=i.getMinZoom(),m=e.viewState.rotation,c=m?getRotatedViewport(e.viewState.center,e.viewState.resolution,m,e.size):void 0;let p=0,u,f,v,R,x,S;for(S=T;S<=a;++S)for(f=i.getTileRangeForExtentAndZ(n,S,f),v=i.getResolution(S),R=f.minX;R<=f.maxX;++R)for(x=f.minY;x<=f.maxY;++x)m&&!i.tileCoordIntersectsViewport([S,R,x],c)||(a-S<=s?(++p,(u=t.getTile(S,R,x,r,o)).getState()==TileState.IDLE&&(g[u.getKey()]=!0,h.isKeyQueued(u.getKey())||h.enqueue([u,d,i.getTileCoordCenter(u.tileCoord),v])),void 0!==l&&l(u)):t.useTile(S,R,x,o));t.updateCacheSize(p,o)}}export default CanvasTileLayerRenderer;