import CanvasLayerRenderer from"./Layer.js";import ImageState from"../../ImageState.js";import ViewHint from"../../ViewHint.js";import{apply as applyTransform,compose as composeTransform,makeInverse,toString as toTransformString}from"../../transform.js";import{containsCoordinate,containsExtent,getHeight,getIntersection,getWidth,intersects as intersectsExtent,isEmpty}from"../../extent.js";import{fromUserExtent}from"../../proj.js";class CanvasImageLayerRenderer extends CanvasLayerRenderer{constructor(e){super(e),this.image_=null}getImage(){return this.image_?this.image_.getImage():null}prepareFrame(e){var t=e.layerStatesArray[e.layerIndex],r=e.pixelRatio,i=e.viewState,a=i.resolution;const n=this.getLayer().getSource();var s=e.viewHints;let o=e.extent;if(void 0!==t.extent&&(o=getIntersection(o,fromUserExtent(t.extent,i.projection))),!s[ViewHint.ANIMATING]&&!s[ViewHint.INTERACTING]&&!isEmpty(o))if(n){e=i.projection;const g=n.getImage(o,a,r,e);g&&(this.loadImage(g)?this.image_=g:g.getState()===ImageState.EMPTY&&(this.image_=null))}else this.image_=null;return!!this.image_}getData(e){var t=this.frameState;if(!t)return null;const r=this.getLayer();t=applyTransform(t.pixelToCoordinateTransform,e.slice()),e=r.getExtent();if(e&&!containsCoordinate(e,t))return null;var e=this.image_.getExtent(),i=this.image_.getImage(),a=getWidth(e),a=Math.floor(i.width*((t[0]-e[0])/a));if(a<0||a>=i.width)return null;var n=getHeight(e),e=Math.floor(i.height*((e[3]-t[1])/n));return e<0||e>=i.height?null:this.getImageData(i,a,e)}renderFrame(e,t){const r=this.image_;var i=r.getExtent(),a=r.getResolution(),[a,n]=Array.isArray(a)?a:[a,a],s=r.getPixelRatio(),o=e.layerStatesArray[e.layerIndex],g=e.pixelRatio,m=e.viewState,h=m.center,l=m.resolution,p=g*a/(l*s),l=g*n/(l*s),c=e.extent,d=m.resolution,f=m.rotation,x=Math.round(getWidth(c)/d*g),c=Math.round(getHeight(c)/d*g),d=(composeTransform(this.pixelTransform,e.size[0]/2,e.size[1]/2,1/g,1/g,f,-x/2,-c/2),makeInverse(this.inversePixelTransform,this.pixelTransform),toTransformString(this.pixelTransform));this.useContainer(t,d,this.getBackground(e));const u=this.getRenderContext(e),y=this.context.canvas;y.width!=x||y.height!=c?(y.width=x,y.height=c):this.containerReused||u.clearRect(0,0,x,c);let I=!1,v=!0;o.extent&&(f=fromUserExtent(o.extent,m.projection),v=intersectsExtent(f,e.extent),(I=v&&!containsExtent(f,e.extent))&&this.clipUnrotated(u,e,f));t=r.getImage(),m=composeTransform(this.tempTransform,x/2,c/2,p,l,0,s*(i[0]-h[0])/a,s*(h[1]-i[3])/n),this.renderedResolution=n*g/s,f=t.width*m[0],x=t.height*m[3];return this.getLayer().getSource().getInterpolate()||(u.imageSmoothingEnabled=!1),this.preRender(u,e),v&&.5<=f&&.5<=x&&(c=m[4],p=m[5],1!==(l=o.opacity)&&(u.save(),u.globalAlpha=l),u.drawImage(t,0,0,+t.width,+t.height,c,p,f,x),1!==l&&u.restore()),this.postRender(this.context,e),I&&u.restore(),u.imageSmoothingEnabled=!0,d!==y.style.transform&&(y.style.transform=d),this.container}}export default CanvasImageLayerRenderer;