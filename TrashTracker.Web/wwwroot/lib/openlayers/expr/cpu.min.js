import{ColorType,LiteralExpression,Ops,overlapsType,parse,typeName}from"./expression.js";import{fromString,lchaToRgba,normalize,rgbaToLcha,withAlpha}from"../color.js";function newEvaluationContext(){return{variables:{},properties:{},resolution:NaN,featureId:null,geometryType:""}}function buildExpression(e,r,s){e=parse(e,s);if(overlapsType(r,e.type))return compileExpression(e,s);throw s=typeName(r),r=typeName(e.type),new Error(`Expected expression to be of type ${s}, got `+r)}function compileExpression(e,r){if(e instanceof LiteralExpression){if(e.type!==ColorType||"string"!=typeof e.value)return function(){return e.value};{const t=fromString(e.value);return function(){return t}}}var s=e.operator;switch(s){case Ops.Number:case Ops.String:case Ops.Coalesce:return compileAssertionExpression(e,r);case Ops.Get:case Ops.Var:return compileAccessorExpression(e,r);case Ops.Id:return e=>e.featureId;case Ops.GeometryType:return e=>e.geometryType;case Ops.Concat:{const o=e.args.map(e=>compileExpression(e,r));return r=>"".concat(...o.map(e=>e(r).toString()))}case Ops.Resolution:return e=>e.resolution;case Ops.Any:case Ops.All:case Ops.Not:return compileLogicalExpression(e,r);case Ops.Equal:case Ops.NotEqual:case Ops.LessThan:case Ops.LessThanOrEqualTo:case Ops.GreaterThan:case Ops.GreaterThanOrEqualTo:return compileComparisonExpression(e,r);case Ops.Multiply:case Ops.Divide:case Ops.Add:case Ops.Subtract:case Ops.Clamp:case Ops.Mod:case Ops.Pow:case Ops.Abs:case Ops.Floor:case Ops.Ceil:case Ops.Round:case Ops.Sin:case Ops.Cos:case Ops.Atan:case Ops.Sqrt:return compileNumericExpression(e,r);case Ops.Case:return compileCaseExpression(e,r);case Ops.Match:return compileMatchExpression(e,r);case Ops.Interpolate:return compileInterpolateExpression(e,r);default:throw new Error("Unsupported operator "+s)}}function compileAssertionExpression(r,s){const t=r.operator,o=r.args.length,a=new Array(o);for(let e=0;e<o;++e)a[e]=compileExpression(r.args[e],s);switch(t){case Ops.Coalesce:return r=>{for(let e=0;e<o;++e){var s=a[e](r);if(null!=s)return s}throw new Error("Expected one of the values to be non-null")};case Ops.Number:case Ops.String:return r=>{for(let e=0;e<o;++e){var s=a[e](r);if(typeof s===t)return s}throw new Error("Expected one of the values to be a "+t)};default:throw new Error("Unsupported assertion operator "+t)}}function compileAccessorExpression(e,r){const s=e.args[0].value;switch(e.operator){case Ops.Get:return e=>e.properties[s];case Ops.Var:return e=>e.variables[s];default:throw new Error("Unsupported accessor operator "+e.operator)}}function compileComparisonExpression(e,r){var s=e.operator;const t=compileExpression(e.args[0],r),o=compileExpression(e.args[1],r);switch(s){case Ops.Equal:return e=>t(e)===o(e);case Ops.NotEqual:return e=>t(e)!==o(e);case Ops.LessThan:return e=>t(e)<o(e);case Ops.LessThanOrEqualTo:return e=>t(e)<=o(e);case Ops.GreaterThan:return e=>t(e)>o(e);case Ops.GreaterThanOrEqualTo:return e=>t(e)>=o(e);default:throw new Error("Unsupported comparison operator "+s)}}function compileLogicalExpression(r,s){var e=r.operator;const t=r.args.length,o=new Array(t);for(let e=0;e<t;++e)o[e]=compileExpression(r.args[e],s);switch(e){case Ops.Any:return r=>{for(let e=0;e<t;++e)if(o[e](r))return!0;return!1};case Ops.All:return r=>{for(let e=0;e<t;++e)if(!o[e](r))return!1;return!0};case Ops.Not:return e=>!o[0](e);default:throw new Error("Unsupported logical operator "+e)}}function compileNumericExpression(r,s){var e=r.operator;const t=r.args.length,o=new Array(t);for(let e=0;e<t;++e)o[e]=compileExpression(r.args[e],s);switch(e){case Ops.Multiply:return r=>{let s=1;for(let e=0;e<t;++e)s*=o[e](r);return s};case Ops.Divide:return e=>o[0](e)/o[1](e);case Ops.Add:return r=>{let s=0;for(let e=0;e<t;++e)s+=o[e](r);return s};case Ops.Subtract:return e=>o[0](e)-o[1](e);case Ops.Clamp:return e=>{var r=o[0](e),s=o[1](e);if(r<s)return s;s=o[2](e);return s<r?s:r};case Ops.Mod:return e=>o[0](e)%o[1](e);case Ops.Pow:return e=>Math.pow(o[0](e),o[1](e));case Ops.Abs:return e=>Math.abs(o[0](e));case Ops.Floor:return e=>Math.floor(o[0](e));case Ops.Ceil:return e=>Math.ceil(o[0](e));case Ops.Round:return e=>Math.round(o[0](e));case Ops.Sin:return e=>Math.sin(o[0](e));case Ops.Cos:return e=>Math.cos(o[0](e));case Ops.Atan:return 2===t?e=>Math.atan2(o[0](e),o[1](e)):e=>Math.atan(o[0](e));case Ops.Sqrt:return e=>Math.sqrt(o[0](e));default:throw new Error("Unsupported numeric operator "+e)}}function compileCaseExpression(r,s){const t=r.args.length,o=new Array(t);for(let e=0;e<t;++e)o[e]=compileExpression(r.args[e],s);return r=>{for(let e=0;e<t-1;e+=2)if(o[e](r))return o[e+1](r);return o[t-1](r)}}function compileMatchExpression(r,s){const t=r.args.length,o=new Array(t);for(let e=0;e<t;++e)o[e]=compileExpression(r.args[e],s);return r=>{var s=o[0](r);for(let e=1;e<t;e+=2)if(s===o[e](r))return o[e+1](r);return o[t-1](r)}}function compileInterpolateExpression(r,s){const i=r.args.length,u=new Array(i);for(let e=0;e<i;++e)u[e]=compileExpression(r.args[e],s);return s=>{var t=u[0](s),o=u[1](s);let a,n;for(let r=2;r<i;r+=2){var p=u[r](s);let e=u[r+1](s);var c=Array.isArray(e);if(c&&(e=withAlpha(e)),o<=p)return 2===r?e:(c?interpolateColor:interpolateNumber)(t,o,a,n,p,e);a=p,n=e}return n}}function interpolateNumber(e,r,s,t,o,a){o-=s;if(0==o)return t;r-=s;return t+(1===e?r/o:(Math.pow(e,r)-1)/(Math.pow(e,o)-1))*(a-t)}function interpolateColor(e,r,s,t,o,a){if(0==o-s)return t;var n=rgbaToLcha(t),p=rgbaToLcha(a);let c=p[2]-n[2];180<c?c-=360:c<-180&&(c+=360);p=[interpolateNumber(e,r,s,n[0],o,p[0]),interpolateNumber(e,r,s,n[1],o,p[1]),n[2]+interpolateNumber(e,r,s,0,o,c),interpolateNumber(e,r,s,t[3],o,a[3])];return normalize(lchaToRgba(p))}export{newEvaluationContext,buildExpression};