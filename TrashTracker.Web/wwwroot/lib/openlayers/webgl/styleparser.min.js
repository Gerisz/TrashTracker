import{BooleanType,ColorType,NumberArrayType,NumberType,StringType,newParsingContext}from"../expr/expression.js";import{ShaderBuilder}from"./ShaderBuilder.js";import{arrayToGlsl,buildExpression,getStringNumberEquivalent,stringToGlsl,uniformNameForVariable}from"../expr/gpu.js";import{asArray}from"../color.js";function expressionToGlsl(e,t,o){const r=newParsingContext();return r.style=e.style,buildExpression(t,o,r,e)}function packColor(e){e=asArray(e);return[256*e[0]+e[1],256*e[2]+Math.round(255*e[3])]}const UNPACK_COLOR_FN=`vec4 unpackColor(vec2 packedColor) {
  return fract(packedColor[1] / 256.0) * vec4(
    fract(floor(packedColor[0] / 256.0) / 256.0),
    fract(packedColor[0] / 256.0),
    fract(floor(packedColor[1] / 256.0) / 256.0),
    1.0
  );
}`;function getGlslSizeFromType(e){return e===ColorType?2:e===NumberArrayType?4:1}function getGlslTypeFromType(e){e=getGlslSizeFromType(e);return 1<e?"vec"+e:"float"}function computeHash(e){return(JSON.stringify(e).split("").reduce((e,t)=>(e<<5)-e+t.charCodeAt(0),0)>>>0).toString()}function parseCommonSymbolProperties(t,o,r,s){if(s+"radius"in t&&"icon-"!==s){let e=expressionToGlsl(r,t[s+"radius"],NumberType);s+"radius2"in t&&(i=expressionToGlsl(r,t[s+"radius2"],NumberType),e=`max(${e}, ${i})`),s+"stroke-width"in t&&(e=`(${e} + ${expressionToGlsl(r,t[s+"stroke-width"],NumberType)} * 0.5)`),o.setSymbolSizeExpression(`vec2(${e} * 2. + 0.5)`)}var i;s+"scale"in t&&(i=expressionToGlsl(r,t[s+"scale"],NumberType|NumberArrayType),o.setSymbolSizeExpression(o.getSymbolSizeExpression()+" * "+i)),s+"displacement"in t&&o.setSymbolOffsetExpression(expressionToGlsl(r,t[s+"displacement"],NumberArrayType)),s+"rotation"in t&&o.setSymbolRotationExpression(expressionToGlsl(r,t[s+"rotation"],NumberType)),s+"rotate-with-view"in t&&o.setSymbolRotateWithView(!!t[s+"rotate-with-view"])}function getColorFromDistanceField(e,t,o,r,s){let i="vec4(0.)";null!==t&&(i=t);t=`(1.0 - smoothstep(-0.63, 0.58, ${e}))`;let a=(i=null!==o&&null!==r?`mix(${o}, ${i}, ${`smoothstep(-${r} + 0.63, -${r} - 0.58, ${e})`})`:i)+" * "+t;return a=null!==s?a+" * "+s:a}function parseImageProperties(e,t,o,r,s){const i=new Image;let a;return i.crossOrigin=void 0===e[r+"cross-origin"]?"anonymous":e[r+"cross-origin"],i.src=e[r+"src"],a=i.complete&&i.width&&i.height?arrayToGlsl([i.width,i.height]):(o[`u_texture${s}_size`]=()=>i.complete?[i.width,i.height]:[0,0],t.addUniform(`vec2 u_texture${s}_size`),`u_texture${s}_size`),o["u_texture"+s]=i,t.addUniform("sampler2D u_texture"+s),a}function parseImageOffsetProperties(e,t,o,r,s){let i=expressionToGlsl(o,e[t+"offset"],NumberArrayType);if(t+"offset-origin"in e)switch(e[t+"offset-origin"]){case"top-right":i=`vec2(${r}.x, 0.) + ${s} * vec2(-1., 0.) + ${i} * vec2(-1., 1.)`;break;case"bottom-left":i=`vec2(0., ${r}.y) + ${s} * vec2(0., -1.) + ${i} * vec2(1., -1.)`;break;case"bottom-right":i=r+` - ${s} - `+i}return i}function parseCircleProperties(e,t,o,r,s){s.functions.circleDistanceField=`float circleDistanceField(vec2 point, float radius) {
  return length(point) - radius;
}`,parseCommonSymbolProperties(e,t,r,"circle-");let i=null,a=("circle-opacity"in e&&(i=expressionToGlsl(s,e["circle-opacity"],NumberType)),"coordsPx");"circle-scale"in e&&(r=expressionToGlsl(s,e["circle-scale"],NumberType|NumberArrayType),a="coordsPx / "+r);let n=null,l=("circle-fill-color"in e&&(n=expressionToGlsl(s,e["circle-fill-color"],ColorType)),null),p=("circle-stroke-color"in e&&(l=expressionToGlsl(s,e["circle-stroke-color"],ColorType)),expressionToGlsl(s,e["circle-radius"],NumberType)),c=null;"circle-stroke-width"in e&&(c=expressionToGlsl(s,e["circle-stroke-width"],NumberType),p=`(${p} + ${c} * 0.5)`);r=getColorFromDistanceField(`circleDistanceField(${a}, ${p})`,n,l,c,i);t.setSymbolColorExpression(r)}function parseShapeProperties(t,e,o,r,s){s.functions.round=`float round(float v) {
  return sign(v) * floor(abs(v) + 0.5);
}`,s.functions.starDistanceField=`float starDistanceField(vec2 point, float numPoints, float radius, float radius2, float angle) {
  float startAngle = -PI * 0.5 + angle; // tip starts upwards and rotates clockwise with angle
  float c = cos(startAngle);
  float s = sin(startAngle);
  vec2 pointRotated = vec2(c * point.x - s * point.y, s * point.x + c * point.y);
  float alpha = TWO_PI / numPoints; // the angle of one sector
  float beta = atan(pointRotated.y, pointRotated.x);
  float gamma = round(beta / alpha) * alpha; // angle in sector
  c = cos(-gamma);
  s = sin(-gamma);
  vec2 inSector = vec2(c * pointRotated.x - s * pointRotated.y, abs(s * pointRotated.x + c * pointRotated.y));
  vec2 tipToPoint = inSector + vec2(-radius, 0.);
  vec2 edgeNormal = vec2(radius2 * sin(alpha * 0.5), -radius2 * cos(alpha * 0.5) + radius);
  return dot(normalize(edgeNormal), tipToPoint);
}`,s.functions.regularDistanceField=`float regularDistanceField(vec2 point, float numPoints, float radius, float angle) {
  float startAngle = -PI * 0.5 + angle; // tip starts upwards and rotates clockwise with angle
  float c = cos(startAngle);
  float s = sin(startAngle);
  vec2 pointRotated = vec2(c * point.x - s * point.y, s * point.x + c * point.y);
  float alpha = TWO_PI / numPoints; // the angle of one sector
  float radiusIn = radius * cos(PI / numPoints);
  float beta = atan(pointRotated.y, pointRotated.x);
  float gamma = round((beta - alpha * 0.5) / alpha) * alpha + alpha * 0.5; // angle in sector from mid
  c = cos(-gamma);
  s = sin(-gamma);
  vec2 inSector = vec2(c * pointRotated.x - s * pointRotated.y, abs(s * pointRotated.x + c * pointRotated.y));
  return inSector.x - radiusIn;
}`,parseCommonSymbolProperties(t,e,r,"shape-");let i=null,a=("shape-opacity"in t&&(i=expressionToGlsl(s,t["shape-opacity"],NumberType)),"coordsPx");"shape-scale"in t&&(r=expressionToGlsl(s,t["shape-scale"],NumberType|NumberArrayType),a="coordsPx / "+r);let n=null,l=("shape-fill-color"in t&&(n=expressionToGlsl(s,t["shape-fill-color"],ColorType)),null),p=("shape-stroke-color"in t&&(l=expressionToGlsl(s,t["shape-stroke-color"],ColorType)),null);"shape-stroke-width"in t&&(p=expressionToGlsl(s,t["shape-stroke-width"],NumberType));r=expressionToGlsl(s,t["shape-points"],NumberType);let c="0.";"shape-angle"in t&&(c=expressionToGlsl(s,t["shape-angle"],NumberType));let u,m=expressionToGlsl(s,t["shape-radius"],NumberType);if(null!==p&&(m=`${m} + ${p} * 0.5`),"shape-radius2"in t){let e=expressionToGlsl(s,t["shape-radius2"],NumberType);null!==p&&(e=`${e} + ${p} * 0.5`),u=`starDistanceField(${a}, ${r}, ${m}, ${e}, ${c})`}else u=`regularDistanceField(${a}, ${r}, ${m}, ${c})`;s=getColorFromDistanceField(u,n,l,p,i);e.setSymbolColorExpression(s)}function parseIconProperties(r,s,e,i,t){let o="vec4(1.0)";"icon-color"in r&&(o=expressionToGlsl(t,r["icon-color"],ColorType)),"icon-opacity"in r&&(o=o+" * "+expressionToGlsl(t,r["icon-opacity"],NumberType));var t=computeHash(r["icon-src"]),e=parseImageProperties(r,s,e,"icon-",t);if(s.setSymbolColorExpression(o+` * samplePremultiplied(u_texture${t}, v_texCoord)`).setSymbolSizeExpression(e),"icon-width"in r&&"icon-height"in r&&s.setSymbolSizeExpression(`vec2(${expressionToGlsl(i,r["icon-width"],NumberType)}, ${expressionToGlsl(i,r["icon-height"],NumberType)})`),"icon-offset"in r&&"icon-size"in r&&(t=expressionToGlsl(i,r["icon-size"],NumberArrayType),e=s.getSymbolSizeExpression(),s.setSymbolSizeExpression(t),a=parseImageOffsetProperties(r,"icon-",i,"v_quadSizePx",t),s.setTextureCoordinateExpression(`(vec4((${a}).xyxy) + vec4(0., 0., ${t})) / (${e}).xyxy`)),parseCommonSymbolProperties(r,s,i,"icon-"),"icon-anchor"in r){var a=expressionToGlsl(i,r["icon-anchor"],NumberArrayType);let e="1.0";"icon-scale"in r&&(e=expressionToGlsl(i,r["icon-scale"],NumberType|NumberArrayType));let t,o=`v_quadSizePx * vec2(0.5, -0.5) + ${t="pixels"===r["icon-anchor-x-units"]&&"pixels"===r["icon-anchor-y-units"]?a+" * "+e:"pixels"===r["icon-anchor-x-units"]?`${a} * vec2(vec2(${e}).x, v_quadSizePx.y)`:"pixels"===r["icon-anchor-y-units"]?`${a} * vec2(v_quadSizePx.x, vec2(${e}).x)`:a+" * v_quadSizePx"} * vec2(-1., 1.)`;if("icon-anchor-origin"in r)switch(r["icon-anchor-origin"]){case"top-right":o="v_quadSizePx * -0.5 + "+t;break;case"bottom-left":o="v_quadSizePx * 0.5 - "+t;break;case"bottom-right":o=`v_quadSizePx * vec2(-0.5, 0.5) + ${t} * vec2(1., -1.)`}s.setSymbolOffsetExpression(s.getSymbolOffsetExpression()+" + "+o)}}function parseStrokeProperties(s,i,a,n,l){if("stroke-color"in s&&i.setStrokeColorExpression(expressionToGlsl(l,s["stroke-color"],ColorType)),"stroke-pattern-src"in s){var p=computeHash(s["stroke-pattern-src"]),a=parseImageProperties(s,i,a,"stroke-pattern-",p);let e=a,t="vec2(0.)",o=("stroke-pattern-offset"in s&&"stroke-pattern-size"in s&&(e=expressionToGlsl(l,s["stroke-pattern-size"],NumberArrayType),t=parseImageOffsetProperties(s,"stroke-pattern-",l,a,e)),"0.");"stroke-pattern-spacing"in s&&(o=expressionToGlsl(l,s["stroke-pattern-spacing"],NumberType)),l.functions.sampleStrokePattern=`vec4 sampleStrokePattern(sampler2D texture, vec2 textureSize, vec2 textureOffset, vec2 sampleSize, float spacingPx, float currentLengthPx, float currentRadiusRatio, float lineWidth) {
  float currentLengthScaled = currentLengthPx * sampleSize.y / lineWidth;
  float spacingScaled = spacingPx * sampleSize.y / lineWidth;
  float uCoordPx = mod(currentLengthScaled, (sampleSize.x + spacingScaled));
  // make sure that we're not sampling too close to the borders to avoid interpolation with outside pixels
  uCoordPx = clamp(uCoordPx, 0.5, sampleSize.x - 0.5);
  float vCoordPx = (-currentRadiusRatio * 0.5 + 0.5) * sampleSize.y;
  vec2 texCoord = (vec2(uCoordPx, vCoordPx) + textureOffset) / textureSize;
  return samplePremultiplied(texture, texCoord);
}`;p="u_texture"+p;let r="1.";"stroke-color"in s&&(r=i.getStrokeColorExpression()),i.setStrokeColorExpression(`${r} * sampleStrokePattern(${p}, ${a}, ${t}, ${e}, ${o}, currentLengthPx, currentRadiusRatio, v_width)`)}if("stroke-width"in s&&i.setStrokeWidthExpression(expressionToGlsl(n,s["stroke-width"],NumberType)),"stroke-offset"in s&&i.setStrokeOffsetExpression(expressionToGlsl(n,s["stroke-offset"],NumberType)),"stroke-line-cap"in s&&i.setStrokeCapExpression(expressionToGlsl(n,s["stroke-line-cap"],StringType)),"stroke-line-join"in s&&i.setStrokeJoinExpression(expressionToGlsl(n,s["stroke-line-join"],StringType)),"stroke-miter-limit"in s&&i.setStrokeMiterLimitExpression(expressionToGlsl(n,s["stroke-miter-limit"],NumberType)),"stroke-line-dash"in s){l.functions.getSingleDashDistance=`float getSingleDashDistance(float distance, float radius, float dashOffset, float dashLength, float dashLengthTotal, float capType) {
  float localDistance = mod(distance, dashLengthTotal);
  float distanceSegment = abs(localDistance - dashOffset - dashLength * 0.5) - dashLength * 0.5;
  distanceSegment = min(distanceSegment, dashLengthTotal - localDistance);
  if (capType == ${stringToGlsl("square")}) {
    distanceSegment -= v_width * 0.5;
  } else if (capType == ${stringToGlsl("round")}) {
    distanceSegment = min(distanceSegment, sqrt(distanceSegment * distanceSegment + radius * radius) - v_width * 0.5);
  }
  return distanceSegment;
}`;let t=s["stroke-line-dash"].map(e=>expressionToGlsl(l,e,NumberType)),e=(t.length%2==1&&(t=[...t,...t]),"0.");"stroke-line-dash-offset"in s&&(e=expressionToGlsl(n,s["stroke-line-dash-offset"],NumberType));p="dashDistanceField_"+computeHash(s["stroke-line-dash"]);const c=t.map((e,t)=>`float dashLength${t} = ${e};`);a=t.map((e,t)=>"dashLength"+t).join(" + ");let o="0.",r=`getSingleDashDistance(distance, radius, ${o}, dashLength0, totalDashLength, capType)`;for(let e=2;e<t.length;e+=2)o=`${o} + dashLength${e-2} + dashLength`+(e-1),r=`min(${r}, getSingleDashDistance(distance, radius, ${o}, dashLength${e}, totalDashLength, capType))`;l.functions[p]=`float ${p}(float distance, float radius, float capType) {
  ${c.join("\n  ")}
  float totalDashLength = ${a};
  return ${r};
}`,i.setStrokeDistanceFieldExpression(p+`(currentLengthPx + ${e}, currentRadiusPx, capType)`)}}function parseFillProperties(r,s,i,e,a){if("fill-color"in r&&s.setFillColorExpression(expressionToGlsl(a,r["fill-color"],ColorType)),"fill-pattern-src"in r){var n=computeHash(r["fill-pattern-src"]),i=parseImageProperties(r,s,i,"fill-pattern-",n);let e=i,t="vec2(0.)";"fill-pattern-offset"in r&&"fill-pattern-size"in r&&(e=expressionToGlsl(a,r["fill-pattern-size"],NumberArrayType),t=parseImageOffsetProperties(r,"fill-pattern-",a,i,e)),a.functions.sampleFillPattern=`vec4 sampleFillPattern(sampler2D texture, vec2 textureSize, vec2 textureOffset, vec2 sampleSize, vec2 pxOrigin, vec2 pxPosition) {
  float scaleRatio = pow(2., mod(u_zoom + 0.5, 1.) - 0.5);
  vec2 pxRelativePos = pxPosition - pxOrigin;
  // rotate the relative position from origin by the current view rotation
  pxRelativePos = vec2(pxRelativePos.x * cos(u_rotation) - pxRelativePos.y * sin(u_rotation), pxRelativePos.x * sin(u_rotation) + pxRelativePos.y * cos(u_rotation));
  // sample position is computed according to the sample offset & size
  vec2 samplePos = mod(pxRelativePos / scaleRatio, sampleSize);
  // also make sure that we're not sampling too close to the borders to avoid interpolation with outside pixels
  samplePos = clamp(samplePos, vec2(0.5), sampleSize - vec2(0.5));
  samplePos.y = sampleSize.y - samplePos.y; // invert y axis so that images appear upright
  return samplePremultiplied(texture, (samplePos + textureOffset) / textureSize);
}`;a="u_texture"+n;let o="1.";"fill-color"in r&&(o=s.getFillColorExpression()),s.setFillColorExpression(`${o} * sampleFillPattern(${a}, ${i}, ${t}, ${e}, pxOrigin, pxPos)`)}}function parseLiteralStyle(r){const s={inFragmentShader:!1,properties:{},variables:{},functions:{},style:r},i={inFragmentShader:!0,variables:s.variables,properties:{},functions:{},style:r},a=new ShaderBuilder,n={};var e;"icon-src"in r?parseIconProperties(r,a,n,s,i):"shape-points"in r?parseShapeProperties(r,a,n,s,i):"circle-radius"in r&&parseCircleProperties(r,a,n,s,i),parseStrokeProperties(r,a,n,s,i),parseFillProperties(r,a,n,s,i),r.filter&&(e=expressionToGlsl(i,r.filter,BooleanType),a.setFragmentDiscardExpression("!"+e)),Object.keys(i.variables).forEach(function(e){const t=i.variables[e];e=uniformNameForVariable(t.name);a.addUniform(getGlslTypeFromType(t.type)+" "+e);let o;o=t.type===StringType?()=>getStringNumberEquivalent(r.variables[t.name]):t.type===ColorType?()=>packColor([...asArray(r.variables[t.name]||"#eee")]):t.type===BooleanType?()=>r.variables[t.name]?1:0:()=>r.variables[t.name],n[e]=o}),Object.keys(i.properties).forEach(function(e){var t=i.properties[e];s.properties[e]||(s.properties[e]=t);let o=getGlslTypeFromType(t.type),r="a_prop_"+t.name;t.type===ColorType&&(o="vec4",r=`unpackColor(${r})`,a.addVertexShaderFunction(UNPACK_COLOR_FN)),a.addVarying("v_prop_"+t.name,o,r)}),Object.keys(s.properties).forEach(function(e){e=s.properties[e];a.addAttribute(getGlslTypeFromType(e.type)+" a_prop_"+e.name)});const t=Object.keys(s.properties).map(function(e){const t=s.properties[e];let o;return o=t.evaluator||(t.type===StringType?e=>getStringNumberEquivalent(e.get(t.name)):t.type===ColorType?e=>packColor([...asArray(e.get(t.name)||"#eee")]):t.type===BooleanType?e=>e.get(t.name)?1:0:e=>e.get(t.name)),{name:t.name,size:getGlslSizeFromType(t.type),callback:o}});for(const o in s.functions)a.addVertexShaderFunction(s.functions[o]);for(const l in i.functions)a.addFragmentShaderFunction(i.functions[l]);return{builder:a,attributes:t.reduce((e,t)=>({...e,[t.name]:{callback:t.callback,size:t.size}}),{}),uniforms:n}}export{expressionToGlsl,packColor,computeHash,parseLiteralStyle};